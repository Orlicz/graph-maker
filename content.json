{"pages":[{"title":"templates","text":"基础定义123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;cassert&gt;using namespace std;#define LOG(f...) fprintf(stderr, f)using ll = long long;template&lt;class T&gt; void read(T &amp;x) { char ch; x = 0; int f = 1; while (isspace(ch = getchar())); if (ch == '-') ch = getchar(), f = -1; do x = x * 10 + (ch - '0'); while(isdigit(ch = getchar())); x *= f;}template&lt;class T, class ...A&gt; void read(T &amp;x, A&amp;... args) { read(x); read(args...); }int main() {#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);#endif return 0;} fread 整数 IO12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;namespace io { const int SIZE = (1 &lt;&lt; 21) + 1; char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1; inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);} inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;} inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();} template&lt;class T&gt; inline void read(T &amp;x) { char ch; int f = 1; x = 0; while(isspace(ch = getc())); if(ch == '-') ch = getc(), f = -1; do x = x * 10 + (ch - '0'); while(isdigit(ch = getc())); x *= f; } template&lt;class T, class ...Args&gt; inline void read(T &amp;x, Args&amp;... args) {read(x); read(args...);} template&lt;class T&gt; inline void write(T x) { static char stk[128]; int top = 0; if(x == 0) {putc('0'); return;} if(x &lt; 0) putc('-'), x = -x; while(x) stk[top++] = x % 10, x /= 10; while(top) putc(stk[--top] + '0'); } template&lt;class T, class ...Args&gt; inline void write(T x, Args... args) {write(x); putc(' '); write(args...);} inline void space() {putc(' ');} inline void endl() {putc('\\n');} struct _flush {~_flush() {flush();}} __flush;};using io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc; 多项式模板暂时只保证 $N \\le 2^{21}$ 时正确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178const int N = 1 &lt;&lt; 19, M = 998244353;using ll = long long;int fac[N], ifac[N];class poly : public vector&lt;int&gt; { using vector&lt;int&gt;::vector; };inline int power(int x, int y) { int p = 1; for (; y; y &gt;&gt;= 1, x = 1LL * x * x % M) if (y &amp; 1) p = 1LL * p * x % M; return p;}inline int inv(int x) { return power(x, M - 2); }void prefac(int n) { fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = 1LL * fac[i - 1] * i % M; ifac[n] = power(fac[n], M - 2); for (int i = n - 1; i &gt;= 0; --i) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % M;}int C(int n, int m) { return 1LL * fac[n] * ifac[m] % M * ifac[n - m] % M; }int A[N], B[N];int w[N], rev[N &lt;&lt; 1], last = 0, Inv[N + 1];void fill_0(int *l, int *r) { memset(l, 0, (r - l) * 4); }void copy_0(int *l, int *r, int *res) { memcpy(res, l, (r - l) * 4); }void polyinit() { auto calc = [](int *w, int N) { w[0] = 1; w[1] = power(3, (M - 1) / N); for (int i = 2; i &lt; N / 2; ++i) w[i] = 1LL * w[i - 1] * w[1] % M; }; auto make_rev = [](int *rev, int N) { int l = __builtin_ctz(N) - 1; for (int i = 1; i &lt; N; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l); }; for (int n = N; n &gt; 1; n &gt;&gt;= 1) { calc(w + N - n, n); make_rev(rev + 2 * (N - n), n); } Inv[1] = 1; for (int i = 2; i &lt;= N; ++i) Inv[i] = M - ll(M / i) * Inv[M % i] % M;}inline int add(int x, int y) { return x + y &gt;= M ? x + y - M : x + y; }inline int sub(int x, int y) { return x - y &lt; 0 ? x - y + M : x - y; }inline void inc(int &amp;x, int y) { x += y; if (x &gt;= M) x -= M; }inline void dec(int &amp;x, int y) { x -= y; if (x &lt; 0) x += M; }// void DFT(int *a, int n) {// int *Rev = rev + 2 * (N - n);// for (int i = 1; i &lt; n; ++i)// if (Rev[i] &gt; i) swap(a[i], a[Rev[i]]);// for (int l = 2, k = 1; k &lt; n; l &lt;&lt;= 1, k &lt;&lt;= 1) {// int *W = w + N - l;// for (int *i = a, *t = a + n; i != t; i += l)// for (int *p = i, *q = i + k, *omega = W, *t = W + k; omega != t; ++p, ++q, ++omega) {// int x = *p, y = (ll)*q * *omega % M;// *p = add(x, y); *q = sub(x, y);// }// }// }void DFT(int *a, int *des, int n) { using u64 = unsigned long long; static u64 f[N]; int *Rev = rev + 2 * (N - n); for (int i = 0; i &lt; n; ++i) f[Rev[i]] = a[i]; u64 *i, *t, *p, *q; int *omega, *tw; for (int l = 2, k = 1; k &lt; n; l &lt;&lt;= 1, k &lt;&lt;= 1) { int *W = w + N - l; for (i = f, t = f + n; i != t; i += l) for (p = i, q = i + k, omega = W, tw = W + k; omega != tw; ++p, ++q, ++omega) { u64 x = *p, y = *q * *omega % M; *p = x + y; *q = x - y + M; } } for (int i = 0; i &lt; n; ++i) des[i] = f[i] % M;}void DFT(int *a, int n) { DFT(a, a, n); }void IDFT(int *a, int n) { DFT(a, n); reverse(a + 1, a + n); int invN = inv(n); for (int *p = a, *t = a + n; p != t; ++p) *p = (ll)*p * invN % M;}void dot(int *a, int *b, int n) { for (int *p = a, *q = b, *t = a + n; p != t; ++p, ++q) *p = (ll)*p * *q % M;}int length(int n) { int l = 1; while (l &lt; n) l &lt;&lt;= 1; return l;}poly operator+(const poly &amp;a, const poly &amp;b) { poly c(max(a.size(), b.size())); copy(a.begin(), a.end(), c.begin()); for (size_t i = 0; i &lt; b.size(); ++i) inc(c[i], b[i]); return c;}poly operator-(const poly &amp;a, const poly &amp;b) { poly c(max(a.size(), b.size())); copy(a.begin(), a.end(), c.begin()); for (size_t i = 0; i &lt; b.size(); ++i) dec(c[i], b[i]); return c;}poly operator*(const poly &amp;f, const poly &amp;g) { int L = length(f.size() + g.size() - 1); fill(A + f.size(), A + L, 0); fill(B + g.size(), B + L, 0); copy(f.begin(), f.end(), A); copy(g.begin(), g.end(), B); DFT(A, L); DFT(B, L); dot(A, B, L); IDFT(A, L); return poly(A, A + f.size() - 1 + g.size());}poly inverse(const poly &amp;f, int n, int SIZE = -1) { poly g = {inv(f[0])}; if (SIZE == -1) g.resize(n); else g.resize(SIZE); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { int cu = min(len * 2, (int)f.size()); copy_n(f.begin(), cu, A); fill(A + cu, A + len * 4, 0); copy_n(g.begin(), len, B); fill(B + len, B + len * 4, 0); DFT(A, len * 4); DFT(B, len * 4); for (int j = 0, li = len * 4; j &lt; li; ++j) A[j] = (2 * B[j] - (ll)B[j] * B[j] % M * A[j]) % M, A[j] += M &amp; (A[j] &gt;&gt; 31); IDFT(A, len * 4); copy(A + len, A + min(len * 2, n), g.begin() + len); } return g;}poly ln(const poly &amp;f, int n, int SIZE = -1) { int len = length(n + min(n, (int)f.size() - 1) - 1); poly g = inverse(f, n, max(len, SIZE)); int li = min((int)f.size() - 1, n); for (int i = 0; i &lt; li; ++i) A[i] = (ll)f[i + 1] * (i + 1) % M; fill(A + li, A + len, 0); DFT(A, len); DFT(g.data(), len); dot(A, g.data(), len); IDFT(A, len); g[0] = 0; for (int i = 1; i &lt; n; ++i) g[i] = (ll)A[i - 1] * Inv[i] % M % M; if (SIZE == -1) g.resize(n); else g.resize(SIZE); return g;}poly exp(const poly &amp;f, int n) { poly g = {1}; g.resize(n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { int up = min(len * 2, n); poly l = ln(g, up); int li = min((int)f.size(), up); for (int j = 0; j &lt; li; ++j) A[j] = sub(f[j], l[j]); for (int j = li; j &lt; up; ++j) A[j] = sub(0, l[j]); A[0] = A[0] + 1 == M ? 0 : A[0] + 1; fill(A + up, A + len * 4, 0); copy_n(g.begin(), len, B); fill(B + len, B + len * 4, 0); DFT(A, len * 4); DFT(B, len * 4); dot(A, B, len * 4); IDFT(A, len * 4); copy(A + len, A + min(len * 2, n), g.begin() + len); } return g;}poly power(const poly &amp;f, int k, int n) { assert(f[0] == 1); poly l = ln(f, n); for (int &amp;x : l) x = (ll)x * k % M; return exp(l, n);}","link":"/templates/"}],"posts":[{"title":"特征多项式优化矩阵快速幂","text":"特征多项式$F(\\lambda) = \\det (\\lambda I - A)$，若 $A$ 为 $n \\times n$ 的矩阵，那么 $F$ 是 $n$ 次多项式 特征多项式的性质 对于 $A$ 的特征值 $\\lambda$，$F(\\lambda) = 0$。 $F(A) = 0$（零矩阵），即 $A^n +c_{n-1}A^{n-1} + \\cdots + c_0 = 0$ （$F$ 是首 $1$ 多项式）(Cayley–Hamilton 定理) 特征多项式与矩阵快速幂 $F(A) = 0$ $A^k = Q(A)F(A) + R(A) = R(A)$ 其中 $R(A)$ 是 $n - 1$ 次的多项式。 如果 $A$ 有值的位置只有 $O(n)$ 个，就可以在 $\\mathcal O(n^3 + n^2 \\log k)$ 时间内用多项式取模计算矩阵快速幂。 对于线性递推等矩阵，可以快速求特征多项式。 一般矩阵求特征多项式相似矩阵：$A$ 和 $P^{-1}AP$ 的特征多项式相同。 证明令 $A$ 的特征多项式 $F(\\lambda)$，$P^{-1}AP$ 的特征多项式 $G(\\lambda)$。 \\begin{aligned} G(\\lambda) &= \\left|\\lambda I - P^{-1}AP\\right|\\\\ &= \\left|\\lambda P^{-1}P - P^{-1}AP \\right| \\\\ &= \\left|P^{-1}(\\lambda I - A)P\\right|\\\\ &= \\left|P^{-1}\\right| F(\\lambda) |P| \\\\ &= F(\\lambda) \\end{aligned}令 $P$ 为初等矩阵。 若左乘 $P$ 为交换行，那么右乘 $P^{-1}$ 为交换列。 若左乘 $P$ 为使第 $j$ 行加上第 $i$ 行的 $k$ 倍，那么右乘 $P$ 为使第 $i$ 列减去第 $j$ 列的 $k$ 倍。（注意到逆矩阵就是多出来的那个数取相反数） 用第 $i + 1$ 行消去 $(i + 2) \\sim n$ 行的第 $j$ 列，右乘的操作就不会产生任何附加影响。 可以将矩阵消成上海森堡矩阵，即主对角线下面多一条对角线。 1234567891011121314151617void hessenburg(int a[N][N], int n) { int i, j, k; for (i = 0; i &lt; n; ++i) { for (j = i + 1; j &lt; n; ++j) if (a[j][i]) break; if (!a[i + 1][i]) continue; if (j != i + 1) { for (k = 0; k &lt; n; ++k) swap(a[i + 1][k], a[j][k]); for (k = 0; k &lt; n; ++k) swap(a[k][i + 1], a[k][j]); } for (j = i + 2; j &lt; n; ++j) { int c = (ll)a[j][i] * power(a[i + 1][i], M - 2) % M; for (k = i; k &lt; n; ++k) a[j][k] = (a[j][k] - (ll)a[i + 1][k] * c) % M; for (k = 0; k &lt; n; ++k) a[k][i + 1] = (a[k][i + 1] + (ll)a[k][j] * c) % M; } }} 求行列式可以考虑对第一列展开，记 $f(i)$ 为右下角 $i \\times i$ 的行列式值。 对于第一行的代数余子式，可以直接转到 $f(i - 1)$ 否则继续对第二列展开，对于第一行可以到 $f(i - 2)$，否则再展开第三列… 可以在 $\\mathcal O(n^2)$ 时间内计算行列式。因为要计算特征多项式，复杂度是 $\\mathcal O(n^3)$（插值或多项式运算） 123456789101112poly charpoly(int a[N][N], int n) { hessenburg(a, n); vector&lt;poly&gt; f(n + 1); f[n - 1] = {-a[n - 1][n - 1], 1}; f[n] = {1}; for (int i = n - 2; i &gt;= 0; --i) { f[i] = poly{-a[i][i], 1} * f[i + 1]; for (int j = i, co = a[j + 1][j]; j &lt; n - 1; ++j, co = (ll)co * a[j + 1][j] % M) f[i] = f[i] + (poly{int(ll(co) * -a[i][j + 1] % M)} * f[j + 2]); } return f[0];} （代码中 $f$ 的顺序与上面相反）","link":"/fast-matrix-power/"},{"title":"Hello World","text":"cc36e87d2743afb112d53e2508dff3fb70ba2fc73a327336a8f1a4d938d2a01cb9e04652a1320b3ed6fc5bc303e0f48c53155dab1d2a826bdd31a1ad2b4f969099c56a2d55b40bad7e0c1f3b8752e52cea71dcc09a3fc935e92dd02ac724caa6a4a515aad26413daca2d00f13487083c77ff74625262d92bf967285f81680a679e242f4401f651fd8f98d29912c3b3cc40a94682341d0caa28b353f671fd2e5739c51809826e4bda794c8e690ff58cd9c58b687fe0925fc79d1eabf012bc2364d67ce2277c3b7b98344e64418c6fd96ac526b89f970dd9ca3d232b86894aec7e023b01e8a622bf80b5a37c6fde02475752b515ec5e4df2164476998807ea81a3d6ec2fcf308274cbda3b4376c61ab9aa602d86b01b92748414bc0858ea2f42f1ce999b4cd2b10fb2c74db874a853171bb4c74db5077aea6cc91d6faabafddf82bbcc17ead5169db4cdf7f9632026ce2402db65c9f96514240cce51a95eed42138af2837fc5f45cd6cae505fdc59cb9f108fc0988ade225c01141d320f14e17122b33ff789b7aeabde5d2d485b7118574bc392657a3f1e75f801fc4e50053e1681c950a5ab21d3e186c18529f30c14b4740cca964e22ce4de7645ccd2c8a48d462e42c551730e4ed285c3c2a41fdbac782a933e21461179d28936eb86a77ca6a1b5c36c6ea77555640ceecc26ff4dc3b46377d200479163e5cfdb51fc174006da3111bf6a67fceca54ef4f8f55028de5ea335c45e894bd43467411b083d65347909642bcfb000b6b9925425cd034a752df9c2ddc7b8b7af94efff95a120fe09a91c16d4a34fe416974e7b2d2d1cc980fe8ed5d770e10ad45f35845fd38ed67f558dbfa03b31ccfc4e5444e737d5add49f7c6ea4d8c8d5840a677413aa72b2727b6fa68e8b06640c9b5b7781ffa8799aea0192cd8305363e0a61aebb2dacd08b0887b02804f340196381145ef3a64e5a84836d5bae98be8ba9368b2030a951b2a93165c51feb3deb96ec7a4f67765350dc3e1f6d28da0ff60fa17bdb6c458849d030d0c580f088f191a3b6f7232ab622a2e0598b90fbedceb9f8a6c177e954ff0022283c71ed4274edb5eff0c847afce87c6eb1922cc66b9005495678434a0c16eba3bba298f62b0560ddba97f57f0b9a7cb691155cda7dff7c98e9f449c4cb15cfc608fb6986c6d1d22d95f48e307a87323c2bf48fe499c8faddfdc8bc384eeccb1800c09ce10153b7f5b827db5dd511357965c63a316087400d59861690ef0afdeb87cfab5ee586497423bc9f14f5e1f38937afad9c883aa82ef47a5754e863937d20a7359e4fc5b6e100eefd377fd028ae11c4c57ff481bf287fac449fe65feae004f290d22741e3367938aef3a71f8c26c9800011b549c8472ae1a998be29c9ffb6bb80daf599c8cbe46b71fbfe49dcb6dd15bc6bef79ac204d93f7b98b6f0a4f684abfade5e3826b8f4a1f8ee7ea290b1e8c5bf0486061f77c6762134e0af70765a75c4d0bd8a52c826af859bb85909ad8dfa8a46499a573e2fb16ea662079550368182a4528ba38c5467eee43361b34dfec54be9c7734bf1de894f9621e76f6705702a98abb3ed539830ec2cb98cdaa671de6b9ce644f71a4f85b579bc34ea6c208f5c6b489e6e2fc53bf9c321dd5b235a2aa373b29fd8e4ff4b4e697a05b10befbd1616e8b4180646420dbd5a4fe07c22acbb4f43bcd4376412a56aa675fbd0081d9c06bdca7d38b854c426a4b3ddeb42bd56c1f10f4f1cc264658dda8eade4671468b7e0949e14b77b7035ee75f7d6028bde2d873a7d4acccbff89597e0f465dbd8128a7f0596f0f49629e24117abb8407bbb1a09f8958bb575990042897ad7533fbcafc112aba609710c48e97a398fb597a7c2d06dbf769c44df305e548749933b6a0555dedc17ce2647dcd27d148c39143617f9f56a71156cab24b38caf7fce8f4314fbf030e67edda582ff697b94f96a98159d299680b1a86c2949633fc85fafa58a6abb58e514ebd6872bf835ab343525ed474f2f72df24106857254c635ad8897d6914a61ef1042f331cdd11e49ee79605f9ad5521dfc4a3d152f5d2aa3aedc3780cb7b626ef828307344ab899210537bcc653ce2fe9578ed267d5f96867a6d70f6d0559b30809eba4c2d64916b370bcfaf6a074083629b8a2577e55ad7bb8f5bfa78a01033c8e4963cc4709ca36140965a37a86bc75df4683f976781380b3276ae5c5d6a5f8be0e2609b58edb468267c3d1ba4d82559439850f2b42370e10319bfad061380ad0ee0c406e493e12dea42cf70f3e56ff09b24f974c48fd7dfe80ada98c483e30999026d554cc6321bd70b026a2a3c3f7be22d338f4137a791f66a1b53e6c512e4f9a09560edd0ac1ef31e68da29d6eaeb46eb5a39a85d456a283efe317918b0017fd855207ffeb73505a6e56361761821e06bf8cff34ba01988a13f48557118175f1439dc6cd8fd132fe782f7f0b393476c133a92ab49788a2b44060dac8aad6c35f12e015f4b694518551d1faaf2483ea893856f4c486760437214d659bde87d2f8f4ed27f00ade7c7741630f679352dfd4bd9fb8fbc62865f4e5d855aea028c78c15e03d8be6a7494f12721dce052a3601852d4d76261eea42d19ad0eff449f1e5094d4d0f38e8ef0be8530a7bade3badbe6a68b203e8978429ec562884036cc58f728087d3bf9ef029b018a0164d830aef5536931cb6fea88ed8e3a18e58a0084bc81ee3ac894c7bc6fc6df6c77079af1982e52ba94fe5453931765de767926ae81a1b9bd4e748fcfbd10be5fd6977a3ad73d1c769235388fd37470dd85ab492d1136940959e4a71b45aab4fe2482dc1e628a7e240c636a319c33a65cba3b0220f853431e694439dbe34cdb84326c7228cb124aa8c176faa01e83b56a4f5c2e1def4946cc8a882fea2a40ede5c05ffa533b5e9eb44d9a959de57048275a5334f0563df358078d5fa4cd43766fcf4246b0a05a9de8aa208a0ae9b3e3bd586be92164a9789b0a4834ed3722f1f754cb8049ad7633fcd3cdff43f0b8452465b81fdf3dd702bd5b1ce01793438e1efe55c40893f42c94fef38d47386d29474aeda91665df27398d478d0ece7f0ea62f0a1094c14ae82bb4338b1a1bf2597425faf5575c2f5 Hey, password is required here.","link":"/hello-world/"},{"title":"AGC009D Uninity","text":"题意求一棵树的最小点分治深度。 $n \\le 1 \\times 10^5$ 题解考虑每个点在点分树上的深度 $d_u$，满足 $d_u = d_v \\implies \\exists x \\text{ on path } (u, v) d_x &lt; d_u$。 在树上定根贪心，将点分树上的深度称为标号。 如果 $u$ 子树中包含未匹配的标号为 $D$ 的点，那么 $d_u \\neq D$。 如果 $u$ 的两颗子树之间存在两个标号为 $D$ 的未匹配点，那么 $d_u &gt; D$。 压位，直接贪心取最小标号即可。（确定一个点的标号后可以匹配子树内标号比它大的点） 复杂度 $\\mathcal O(n \\log n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;#include &lt;vector&gt;using namespace std;#define LOG(f...) fprintf(stderr, f)using ll = long long;template&lt;class T&gt; void read(T &amp;x){ char ch; x = 0; int f = 1; while (isspace(ch = getchar())); if (ch == '-') ch = getchar(), f = -1; do x = x * 10 + ch - '0'; while(isdigit(ch = getchar())); x *= f;}template&lt;class T, class ...A&gt; void read(T &amp;x, A&amp;... args) { read(x); read(args...); }const int N = 100005;int f[N];vector&lt;int&gt; G[N];int dfs(int x, int fa) { int OR = 0, AND = 0, res = 0; for (int v : G[x]) { if (v == fa) continue; res = max(res, dfs(v, x)); AND |= (OR &amp; f[v]); OR |= f[v]; } for (int i = 0; ; ++i) { if ((OR &gt;&gt; i) &amp; 1) OR ^= (1 &lt;&lt; i); else if ((AND &gt;&gt; i) == 0) { f[x] = OR ^ (1 &lt;&lt; i); return max(res, i); } }}int main() {#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;answer.txt&quot;, &quot;w&quot;, stdout);#endif int n; read(n); for (int i = 1; i &lt; n; ++i) { int u, v; read(u, v); G[u].push_back(v); G[v].push_back(u); } printf(&quot;%d\\n&quot;, dfs(1, 0)); return 0;}","link":"/AGC009D/"},{"title":"AGC022D Shopping","text":"AtCoder 考虑直接计算轮数乘 $2L$。 如果 $t_i \\ge 2L$ 是没有用处的，所以令 $t_i \\gets t_i \\bmod 2L$，多余部分直接计入答案。 如果列车从左边进入，右边回来时恰好能购物完，即 $t_i \\le 2(L - x_i)$，那么令 $l_i = 1$，类似地定义 $r_i$，用二元组 $(l_i, r_i)$ 表示一个站。 如果对于每个站都单独前往，让车开一轮后再返回，总共需要 $n + 1$ 轮。 那么如果有站 $i &lt; j, r_i = 1, l_j = 1$，那么可以先从左边去 $j$，返回时从右边进入 $i$，最后返回起点，就可以省下一轮，那么将 $(i, j)$ 匹配。 注意到不会有 $(0, 1), (1, 0)$ 匹配的情况，每一对中一定有 $(1, 1)$，那么顺序贪心，优先将 $(1, 1)$ 与 $(0, 1), (1, 0)$ 匹配，最后剩下一些 $(1, 1)$ 一起匹配。 注意一些特殊情况： 注意到若 $l_n = 1$，可以单独将答案 $-1$，如只有一个点时答案可能为 $1$，即 $n$ 号点和其他点是独立的。 如果 $t_i = 0$，那么直接忽略，保证轮数不为 $0$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;cassert&gt;using namespace std;#define LOG(f...) fprintf(stderr, f)using ll = long long;template&lt;class T&gt; void read(T &amp;x){ char ch; x = 0; int f = 1; while (isspace(ch = getchar())); if (ch == '-') ch = getchar(), f = -1; do x = x * 10 + ch - '0'; while(isdigit(ch = getchar())); x *= f;}template&lt;class T, class ...A&gt; void read(T &amp;x, A&amp;... args) { read(x); read(args...); }const int N = 300005;int x[N], t[N];bool L[N], R[N];int main() {#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);#endif int n; ll len; read(n, len); for (int i = 1; i &lt;= n; ++i) read(x[i]); for (int i = 1; i &lt;= n; ++i) read(t[i]); int cntB = 0, cntR = 0, res = n + 1; for (int i = 1; i &lt; n; ++i) { res += t[i] / (2 * len); t[i] %= (2 * len); if (t[i] == 0) { --res; continue; } bool L = 2 * (len - x[i]) &gt;= t[i]; bool R = 2 * x[i] &gt;= t[i]; if (L &amp;&amp; !R &amp;&amp; cntB) --cntB, --res; else if (R &amp;&amp; !L) ++cntR; else if (L &amp;&amp; R &amp;&amp; cntR) --cntR, --res; else if (L &amp;&amp; R) ++cntB; } res += t[n] / (2 * len); t[n] %= (2 * len); if (2 * (len - x[n]) &gt;= t[n]) --res; res -= cntB / 2; res = max(res, 1); printf(&quot;%lld\\n&quot;, 2LL * len * res); return 0;}","link":"/AGC022D/"},{"title":"AGC035F Two Histograms","text":"在一个 $N \\times M$ 网格中，每次操作可以给某行或某列的一个前缀 $+1$（每行每列只操作一次，可以不操作），求最终填数方案数。 题解注意到如果可以把某行的一个前缀变长 $1$，而某列前缀变短 $1$，值不变，那么这两种情况是重复的。 不存在这种情况的方案和填数结果一一对应，所以对这种情况容斥即可。 答案为 \\sum_{i=0}^{n} \\binom{n}{i}\\binom{m}{i} \\cdot i! \\cdot (n+1)^{m-i} (m+1)^{n-i} 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define LOG(f...) fprintf(stderr, f)using ll = long long;const int N = 500005;const int M = 998244353;int power(int x, int y) { int p = 1; for (; y; y &gt;&gt;= 1, x = (ll)x * x % M) if (y &amp; 1) p = (ll)p * x % M; return p;}int fac[N], ifac[N];void prefac(int n) { fac[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = (ll)fac[i - 1] * i % M; ifac[n] = power(fac[n], M - 2); for (int i = n; i; --i) ifac[i - 1] = (ll)ifac[i] * i % M;}int C(int n, int m) { return (ll)fac[n] * ifac[m] % M * ifac[n - m] % M; }int main() {#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);#endif int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); prefac(m); int res = 0; for (int i = 0; i &lt;= n; ++i) res = (res + (ll)C(n, i) * C(m, i) % M * power(m + 1, n - i) % M * power(n + 1, m - i) % M * fac[i] * ((i &amp; 1) ? -1 : 1)) % M; printf(&quot;%d\\n&quot;, (res + M) % M); return 0;}","link":"/AGC035F/"},{"title":"CF559E Gerald and Path","text":"题意给定 $n$ 个二元组 $(p, l)$，表示数轴上 $[p - l, p]$ 和 $[p, p + l]$ 两条线段中恰好选一条。 最大化覆盖的总长度。 $n \\le 100$ 题解按 $p$ 排序，设 DP 状态 $f(i, r)$ 表示点 $1 \\sim i$ 覆盖 $(-\\infty, r]$ 的最大长度。 考虑第 $i$ 个点的方向： 第 $i$ 个点向右，转移为 $f(i, p_i + l_i) \\gets f(i - 1, p_i) + l_i$ 第 $i$ 个点向左，枚举 $j$ 使得编号区间 $(j, i)$ 内的点向右，假设只有这些点能向右延伸到 $p_i$ 右侧，$[1, j]$ 中的点任意指向（不能向右延伸），则转移为 $f(i, R) \\gets f(j, p_i - l_i) + l_i + (R - p_i)$，其中 $R = \\max_{k\\in(i, j)}\\{i + l_i\\}$。 对于第二种转移，我们只考虑了 $i$ 左边向右指且超过了 $i$ 的贡献，注意到 $i$ 左边有两个点 $j &lt; k$，且 $j$ 向右指，$k$ 向左指，且对答案都有贡献，那么 $j, k$ 可以完全覆盖 $i$ 向左指的区间，那么 $i$ 向左指就是没有必要的。 最后更新 $f(i, k) \\gets f(i, j) - |j - k|$ （其中 $k &lt; j$），$f(i, j) \\gets f(i, k)$（其中 $j &gt; k$）即可。 实现时需要离散化。 时间复杂度 $\\mathcal O(n^2)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;cassert&gt;using namespace std;#define LOG(f...) fprintf(stderr, f)using ll = long long;template&lt;class T&gt; void read(T &amp;x) { char ch; x = 0; int f = 1; while (isspace(ch = getchar())); if (ch == '-') ch = getchar(), f = -1; do x = x * 10 + (ch - '0'); while(isdigit(ch = getchar())); x *= f;}template&lt;class T, class ...A&gt; void read(T &amp;x, A&amp;... args) { read(x); read(args...); }void upmax(int &amp;x, int y) { if (x &lt; y) x = y; }const int N = 105;struct line { int p, l, r;} l[N];int f[N][N * 3];vector&lt;int&gt; pos;int dist(int i, int j) { return abs(pos[i] - pos[j]);}int main() {#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);#endif int n; read(n); for (int i = 1; i &lt;= n; ++i) { read(l[i].p, l[i].l); l[i].r = l[i].p + l[i].l; l[i].l = l[i].p - l[i].l; pos.emplace_back(l[i].p); pos.emplace_back(l[i].l); pos.emplace_back(l[i].r); } sort(pos.begin(), pos.end()); pos.erase(unique(pos.begin(), pos.end()), pos.end()); auto norm = [&amp;](int &amp;x) { x = lower_bound(pos.begin(), pos.end(), x) - pos.begin(); }; for (int i = 1; i &lt;= n; ++i) norm(l[i].l), norm(l[i].p), norm(l[i].r); sort(l + 1, l + 1 + n, [](const line &amp;a, const line &amp;b) { return a.p &lt; b.p; }); for (int i = 1; i &lt;= n; ++i) { copy_n(f[i - 1], pos.size(), f[i]); upmax(f[i][l[i].r], f[i - 1][l[i].p] + dist(l[i].p, l[i].r)); int R = l[i].p; for (int j = i - 1; j &gt;= 0; --j) { upmax(f[i][R], f[j][l[i].l] + dist(l[i].l, R)); if (j) R = max(R, l[j].r); } for (int j = pos.size() - 1; j; --j) upmax(f[i][j - 1], f[i][j] - dist(j, j - 1)); for (int j = 0; j &lt; (int)pos.size() - 1; ++j) upmax(f[i][j + 1], f[i][j]); } printf(&quot;%d\\n&quot;, f[n][pos.size() - 1]); return 0;}","link":"/CF559E/"},{"title":"不过斜率为整数的直线的格路计数","text":"结论在网格图上从 $(0, 0)$ 走到 $(W, AW + B)$，且不穿过 $y = Ax + B$ 这条直线的方案数为 \\binom{W + AW + B}W - A \\times \\binom{W + AW + B}{W - 1}证明枚举折线第一次穿出的位置，为 $(p, Ap + B) \\to (p, Ap+B+1)$。 那么之后有 \\binom{(W - p) + (AW + B - Ap - B - 1)}{W - p} = \\binom{(W - p)(A + 1) - 1}{W - p}种走法。 而 \\binom{(W - p)(A + 1) - 1}{W - p} = A\\binom{(W - p)(A + 1) - 1}{W - p - 1}可以展开验证。 则不合法方案数为 \\begin{aligned} &A\\sum_{p} \\binom{(A + 1)p + B}{p}\\binom{(W - p)(A + 1) - 1}{W - p - 1} \\\\ =&A \\times \\binom{W + AW + B}{W - 1} \\end{aligned}","link":"/lattice-path/"}],"tags":[{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"贪心, ad-hoc","slug":"贪心-ad-hoc","link":"/tags/%E8%B4%AA%E5%BF%83-ad-hoc/"},{"name":"计数","slug":"计数","link":"/tags/%E8%AE%A1%E6%95%B0/"},{"name":"数学 线性代数","slug":"数学-线性代数","link":"/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"组合数学，结论","slug":"组合数学，结论","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E7%BB%93%E8%AE%BA/"}],"categories":[{"name":"solution","slug":"solution","link":"/categories/solution/"},{"name":"math","slug":"math","link":"/categories/math/"},{"name":"combinatroics","slug":"math/combinatroics","link":"/categories/math/combinatroics/"}]}